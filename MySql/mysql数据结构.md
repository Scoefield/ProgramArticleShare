## 前言

### 索引结构及查找算法

一个 sql 语句在 mysql 里究竟是如何运行的呢？又是怎么去查找的呢？
其中就涉及到数据库（存储数据）以及查找算法。
先来看一下几种查找算法；

- 目录查找：类似索引
- 遍历：暴力查找
- 二分：B+树的基础算法
- 键查找：hash 查找

能做索引的数据结构有：数组、链表、红黑树、B 树(B-树、B+树)。

那么哪种数据结构适合做 MySql 数据库的存储结构呢？

先来说下数据的一般存储方式：内存(适合小数据量)、磁盘(大数据量)。  
磁盘的运转方式：速度 + 旋转，磁盘页的概念：每一页大概 16KB。

### 不适合做 MySql 的数据结构及其原因

**数组和链表**的缺点就是数据量大的时候存不了，也就是说不合适大数据量。

**哈希**是通过 hash 函数计算出一个 hash 值的，存在哈希碰撞的情况，另外哈希也不支持部分索引查询以及范围查找。但是哈希的优点就是查找的时间复杂度是 O(1)，那么什么情况下可以使用 hash 索引呢？就是查询条件不会变，而且没有部分查询和范围查询的时候。

**红黑树**存储的数据量大的时候，红黑树的节点层数多，也就是树的高度比较高，查找的底层数据时，查找次数就比较多，即对磁盘 IO 使用比较频繁。总结为以下两点：

1. **读取浪费太多**：通过计算本来树的每一层大概需要分配**16KB**的数据，但是对于红黑树来说，实际存的节点数比较少，即存的数据大小远远小于**16KB**，从而造成存储空间的浪费
2. **读取磁盘的次数过多**：树的层数越多，查找数据时读取磁盘的次数也就越多

如下图所示，如果需要查找数字**4**的话，需要查找三次，即对磁盘 IO 操作三次：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18d3ee56283f455d946f266d1d6a5795~tplv-k3u1fbpfcp-watermark.image)

我们想下，那为什么红黑树又可以在 hashMap 的查找那里用呢？  
这就涉及到磁盘和内存的区别了，这里就不展开解释了，只需要知道是因为 hashMap 使用到是内存就可以了。

## BTree 和 B+Tree 的引出

针对红黑树以上总结的两点(不适合用来做 mysql 的数据结构的原因)，有什么可以改进的方法呢？我们可以从以下两点出发：

1. 增加树每层的节点数量，这样可以对分配的 16KB 充分利用，即解决上面的读取浪费的问题
2. 尽可能的让树的高度减小，使得树显得比较“矮胖”，这样可以减少读取磁盘的次数

那么怎么样才可以实现以上的方法呢？这就需要用到 B+树了，实际上 MySql 的底层数据结构就是用的 B+树。

### BTree 数据结构

**N 阶的 BTree 的几个重要特性：**

1. 节点最多含有 N 颗子树(指针)，N-1 个关键字(数据存储空间) (N>=2);
2. 除了根节点和叶子节点外，其它每个节点至少有 M=N/2 个子节点，M 向上取整，即分裂的时候从中间分开，分成 M 棵子树；
3. 若根节点不是叶子结点，则至少有两颗子树。

什么意思呢，我们来看下面这颗三阶的 B 树，结构大概长这样：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03f3ec0310074e018e8d58eeca737094~tplv-k3u1fbpfcp-watermark.image)

BTree 有一个非常重要的操作，当一颗树不满足以上的性质的时候，会进行怎样的操作？红黑色大家已经知道了会进行变换颜色、左旋或右旋操作（[二叉树、红黑树以及 Golang 实现红黑树](https://juejin.cn/post/6956608574726340639)）。而 BTree 会进行分裂操作。

先来看个例子：

创建一棵 5 阶的 BTree，插入的数据有：2，13，6，1，7，4，10，12，5，16，22。  
根据 BTree 的特性，5 阶则在磁盘的页中最多有 5 个指针(存储查找路径的地址)、4 个存储空间(存储关键字，即需要存的数据)，那么具体的插入数据如下所示：
![btree-1.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/450114b9cbe0401b80f4885ef86b9b0e~tplv-k3u1fbpfcp-watermark.image)

当插入 7 的时候，发现空间不足，此时就会出现分裂操作，从中间节点分开，把中间节点移到根节点，如下：
![btree-2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f5dc1fe23e34f3d8df3ab46da5e5d99~tplv-k3u1fbpfcp-watermark.image)

当插入 16 的时候，比 6 大，应该插入到右子树 13 的右边的，但是发现的空间不够，此时又会进行分裂操作，从右子树的中间节点(12)分开，把中间节点移到根节点，然后分裂成左右子树，这时一共有三颗子树了，如下所示：
![btree-3.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/170833c01f9c481da57e2a9850165101~tplv-k3u1fbpfcp-watermark.image)

最后插入 22 得到的一颗完整的树如下：
![btree-4.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c435826d4e2420db59a442ad5c73829~tplv-k3u1fbpfcp-watermark.image)

大家也可以添加多其它数据，然后看看分裂后的效果，这里就不一一列举了。

需要注意的是：分裂后的树节点仍要满足 BTree 的特性，其实也是满足二叉查找树(二叉排序树)的特点，如果忘了的同学，可以参考前面写的一篇文章：[二叉树、红黑树以及 Golang 实现红黑树](https://juejin.cn/post/6956608574726340639)。  
可以看到左子树的值比 6 小，中间节点的值(7、10)介于 6 和 12 之间，右子树的值均比 12 大。总的来说就是从左到右是有序的。

以上操作是 BTree 构建的详细过程，需要注意的是在构建过程中进行分裂的操作，分裂后必须关注的是是否仍满足了 BTree 的特性，是否是一颗二叉排序树。有时候插入一个数时，可能会经过多次分裂操作。

回过头来看上面提到的两个问题：1.**读取浪费太多**；2.**磁盘读取次数过多**。根据 BTree 的特点，我们可以看到 BTree 的查找效率还是挺高的，也能够解决这两个问题。但是 MySql 还是没有选择使用 BTree 数据结构，这是为什么呢？

主要原因有以下这几点：

1. **因为 BTree 不适合范围查找**。就拿上面的来举例，比如我要查找小于 6 的数据，则先找到 6 的节点，然后需要**遍历**一遍 6 节点(索引)的左子树，不遍历的话，就拿不到小于 6 的这些数据了，也就说索引失效了，所以说不适合范围查找。
2. BTree 的节点除了存储**索引**之外，还存储了**数据**本身，占用空间较大，但是磁盘的页大小是有限的(16KB 左右)，因此，存储同样大小的数据，BTree 显得比较高(相对 B+Tree)，稳定性弱一些。

综上两个主要原因，MySql 最终选择了**B+Tree**的数据结构来存储数据。

### B+Tree 数据结构

B+Tree 和 BTree 的分裂过程类似，只是 B+Tree 的叶子节点不会存储数据，所有的数据都是存储在叶子节点，其目的是为了增加系统的稳定性。这里就不再列举 B+Tree 的分裂过程了，我们直接看下 B+Tree 到底长啥样，如下图所示：

![btree-5.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cd1300bbeed477fa4da6a2ac9590b46~tplv-k3u1fbpfcp-watermark.image)

实际上 MySql 的底层数据结构 B+Tree 是长这样的，如下图所示：

![btree-6.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bd5659ebee04575bf601d44842c2124~tplv-k3u1fbpfcp-watermark.image)

大家可以看出 B+Tree 与 BTree 有啥不一样呢？由上图可以看出 B+Tree 有以下几个特点：

1. 叶子节点连起来了，是一条有序的双向链表，目的是为了解决范围查找。比如需要查找小于 9 的数据，只要找到等于 9 的数据，然后将 9 的左边数据全部拿出来即可。
2. 非叶子节点不存数据，只存索引，空间利用更高效。
3. 数据的个数和节点一样多，换句话说，非叶子节点存的是其子树的最大或最小值。

对于索引失效的情况，BTree 是需要遍历整棵树才能把所有数据拿到，而 B+Tree 只需要找到叶子节点的第一个节点即可把所有数据拿到，可见效率是 B+Tree 更优，这就是双向链表的妙用。

## 计算 m 阶，即 B+Tree 该取多少合适

m 是怎么计算出来的呢？是根据磁盘的页大小来结算的。

我们知道，磁盘的页大小大概是 16K，MySql 创建索引时，可以根据字段及类型来计算磁盘一页大概可以存多少数据。  
根据官方文档描述，树高度等于 2 时(2 阶)，大概可以存两万多条数据；高度等于 3 时(3 阶)，大概可以存两千多万条数据，怎么计算的呢？  
首先，1 千字节(KB)=1024 字节(B)，一页有 16KB，假设存**主键+指针**大概有 14B(8+6)，则一页就可以存：16\*1024/(8+6)=**1170** 个索引了。

对于 3 阶的 B+Tree 来说，大概可以存：1170*1170*1170 条数据，大概是两千万。

## 总结

BTree 是 B+Tree 的一个过渡，B+Tree 适合用于大数据量的磁盘索引数，经典的就是上面讲到的作为 MySql 的底层索引结构，所有的数据都存在叶子节点，其它节点只存储索引，增加了系统的稳定性、提高查找效率以及查询时减少磁盘的 IO 操作。
