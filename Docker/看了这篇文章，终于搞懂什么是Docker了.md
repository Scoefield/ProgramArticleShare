文章大纲

## 什么是 Docker

`Docker` 的英文翻译是“集装箱”的意思，也通常叫 `Container`，Container 里面装的是任意类型的 App，我们的开发人员可以通过 Docker 将 App 变成一种标准化的、可移植的、自管理的组件，我们可以在任何主流的操作系统中开发、调试和运行。

是一个 C/S 架构的应用程序，主要包含下面几个组件：

- 常驻后台进程 Dockerd
- 一个用来和 Dockerd 交互的 REST API Server
- 命令行 CLI 接口，通过和 REST API 进行交互（我们经常使用的 docker 命令）

从概念上来看 Docker 和我们传统的虚拟机比较类似，只是更加轻量级，更加方便使，Docker 和虚拟机最主要的区别有以下几点：

- 虚拟化技术依赖的是物理机器的 CPU 和内存，是硬件级别的；而 Docker 是构建在操作系统层面的，利用操作系统的容器化技术，同样是可以运行在虚拟机上面。
- 我们知道虚拟机中的系统就是我们常说的操作系统镜像，比较复杂；而 Docker 比较轻量级，我们可以用 Docker 部署一个独立的 Redis，就类似于在虚拟机当中安装一个 Redis 应用，但是我们用 Docker 部署的应用是完全隔离的。
- 我们都知道传统的虚拟化技术是通过快照来保存状态的；而 Docker 引入了类似于源码管理的机制，将容器的快照历史版本一一记录下来，切换成本非常之低。
- 传统虚拟化技术在构建系统的时候非常复杂；而 Docker 可以通过一个简单的 Dockerfile 文件来构建整个容器，更重要的是 Dockerfile 可以手动编写，这样应用程序开发人员可以通过发布 Dockerfile 来定义应用的环境和依赖，这样对于持续交付非常有利。

![](https://files.mdnice.com/user/24277/18ac62ac-bab1-4c3b-a6b3-42366680ba78.png)

## Docker 架构及基本概念

Docker 使用 C/S （客户端/服务器）体系的架构，Docker 客户端与 Docker 守护进程通信，Docker 守护进程负责构建，运行和分发 Docker 容器。Docker 客户端和守护进程可以在同一个系统上运行，也可以将 Docker 客户端连接到远程 Docker 守护进程。Docker 客户端和守护进程使用 REST API 通过 UNIX 套接字或网络接口进行通信。

### Docker 架构

![](https://files.mdnice.com/user/24277/dfa81f66-d3d5-4325-9020-6c2dd76cb175.png)

### 基本概念

- **Docker Damon**：dockerd，用来监听 Docker API 的请求和管理 Docker 对象，比如镜像、容器、网络和 Volume。
- **Docker Client**：docker client 是用户和 Docker 进行交互的最主要的方式，比如可以通过 docker run 命令来运行一个容器，然后我们的这个 client 会把命令发送给上面的 Dockerd，让它来做真正事情。
- **Docker Registry**：用来存储 Docker 镜像的仓库，`Docker Hub` 是 Docker 官方提供的一个公共仓库，而且 Docker 默认也是从 Docker Hub 上查找镜像的，当然你也可以很方便的运行一个私有仓库。当我们使用 `docker pull` 或者 docker run 命令时，就会从我们配置的 Docker 镜像仓库中去拉取镜像，使用 `docker push` 命令时，会将我们构建的镜像推送到对应的镜像仓库中。
- **Images**：镜像，镜像是一个只读模板，带有创建 Docker 容器的说明，一般来说的，镜像会基于另外的一些基础镜像并加上一些额外的自定义功能。比如，你可以构建一个基于 Centos 的镜像，然后在这个基础镜像上面安装一个 Nginx 服务器，这样就可以构成一个属于我们自己的镜像了。
- **Containers**：容器，容器是一个镜像的可运行的实例，可以使用 Docker REST API 或者 CLI 来操作容器，容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。
- **底层技术支持**：Namespaces（做隔离）、CGroups（做资源限制）、UnionFS（镜像和容器的分层） the-underlying-technology Docker 底层架构分析。

其实主要理解了“**镜像**”、“**容器**”和“**仓库**”这三个概念就相当于理解了 Docker 的一半了。

## 为什么要使用 Docker

作为一种新兴的虚拟化方式， Docker 跟传统的虚拟化方式相比具有众多的优势。

### 更高效的利用系统资源

由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销， Docker 对系统资源的利用率更
高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚
拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。

### 更快速的启动时间

传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内
核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测
试、部署的时间。

### 一致的运行环境

开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些
bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应
用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。

### 持续交付和部署

对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。

使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过
Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测
试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous
Delivery/Deployment) 系统进行自动部署。

而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团
队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。

### 更轻松的迁移

由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。 Docker 可以在很多平台
上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可
以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无
法正常运行的情况。

### 更轻松的维护和扩展

Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护
更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外， Docker 团队同各个开源项
目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定
制，大大的降低了应用服务的镜像制作成本。

### 对比传统虚拟机总结

| 特性       |    容器(Docker)    |     虚拟机 |
| :--------- | :----------------: | ---------: |
| 启动       |        秒极        |     分钟级 |
| 硬盘使用   |     一般为 MB      |  一般为 GB |
| 性能       |      接近原生      |   相对较弱 |
| 系统支持量 | 单机支持上千个容器 | 一般几十个 |
